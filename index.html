<!doctype html>
<html>
	<head>
		<title>Traffic</title>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript" src="utils.js"></script>
		<script type="text/javascript" src="interface.js"></script>
		<script type="text/javascript">
    var canvas = new Object;
    canvas.width   = window.innerWidth;
    canvas.height  = window.innerHeight;

	var grid = [];

	window.onload = function(){
		document.getElementById( "game-canvas" ).setAttribute( "width", canvas.width );
		document.getElementById( "game-canvas" ).setAttribute( "height", canvas.height );
		init_cached_canvases();
	};

	function reset(){
		usage_history = [];
		init_places( game.place_count );
		init_travelers( game.traveler_count );
	}

	function init_cached_canvases(){
		// Place canvas
		var canvas_element = document.getElementById( "place-canvas" );
		var context = canvas_element.getContext( "2d" );
		context.beginPath();
		context.arc( game.sizes.place, game.sizes.place, game.sizes.place , 0, 2 * Math.PI );
		context.stroke();

		var canvas_element = document.getElementById( "traveler-canvas" );
		var context = canvas_element.getContext( "2d" );
		diameter = 1;
		context.beginPath();
		context.arc( game.sizes.traveler, game.sizes.traveler, game.sizes.traveler , 0, 2 * Math.PI );
		context.strokeStyle = '#ff0000';
		context.stroke();
	}

	var game = {
		displays: {
			potential_places: true,
			goals:            true,
			places:           true,
			travelers:        true,
			next_chosen:      false,
			history:          true,
		},
		options: {
			layout:           'random',
		},
		traveler_count: 1,
		place_count:    1000,
		single_goal:    true,

		sizes: {
			place: 6,
			traveler: 4,
		},
	}

    var mainloop = function() {
	    clear_canvas();
        updateGame();
        drawGame();
        get_framerate();

    };

	function clear_canvas(){
		var canvas_element  = document.getElementById( "game-canvas" );
		var context = canvas_element.getContext("2d");
		context.clearRect( 0, 0, canvas.width, canvas.height ); // clear canvas
	}

    var animFrame = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            null ;

    var recursiveAnim = function() {
        mainloop();
        animFrame( recursiveAnim );
    };

	var usage_history = [];

	var places = new Array();
	init_places( game.place_count );
    var valid_places = new Array();
    var travelers = new Array();
	init_travelers( game.traveler_count );

    // start the mainloop
    animFrame( recursiveAnim );

	var did_tally = false;
    function updateGame(){
		// Game logic?
		for( var count in travelers ){
			traveler = travelers[ count ];
			if ( traveler.arrived ){
				continue;
			}

			if ( traveler.next_place == null || traveler.has_arrived( traveler.next_place ) ) {
				if ( traveler.next_place !== null ){
					traveler.distance_traveled += get_distance( places[ traveler.last_place ], places[ traveler.next_place ] );
					travelers[ count ] = traveler;
					if ( traveler.last_place > traveler.next_place ){
						path_key = traveler.last_place + "." + traveler.next_place;
					} else {
						path_key = traveler.next_place + "." + traveler.last_place;
					}

					if (usage_history[ path_key ] == null ){
						usage_history[ path_key ] = 1;
					} else {
						usage_history[ path_key ] += .5;
					}
				}
				// Have we reached our final goal?
				if ( traveler.has_arrived( traveler.goal_place_index ) ){
					traveler.arrived = true;
					travelers[ count ] = traveler;
					continue;
				}

				// we need to choose a direction to go next
				traveler.choose_next_place();
				place = places[ traveler.next_place ];
				x_distance = traveler.x - place.x;
				y_distance = traveler.y - place.y;
				if ( Math.abs( x_distance ) > Math.abs( y_distance ) ){
					traveler.x_speed = 1;
					traveler.y_speed = Math.abs( y_distance ) / Math.abs( x_distance );
				} else {
					traveler.y_speed = 1;
					traveler.x_speed = Math.abs( x_distance ) / Math.abs( y_distance );
				}
				if ( x_distance > 0 ){
					traveler.x_speed = traveler.x_speed * -1;
				}
				if ( y_distance > 0 ){
					traveler.y_speed = traveler.y_speed * -1;
				}
			}

			// Now move the traveler towards the next place

			traveler.x += traveler.x_speed;
			traveler.y += traveler.y_speed;
			travelers[ count ] = traveler;
		}

		done_traveling = true;
		for( var count in travelers ){
			if ( ! travelers[ count ].arrived ) {
				done_traveling = false;
			}

		}
		if ( done_traveling && ! did_tally){
				console.log( "Everyone has arrived" );
				// Tally up the totals:
				total_stops = 0;
				total_travelers = 0;
				total_distance  = 0;
				for ( var count in travelers ){
					traveler = travelers[ count ];
					stops = traveler.history.length;
					total_stops += stops;
					total_distance += traveler.distance_traveled;
					total_travelers++;
				}
				average_stops = total_stops / total_travelers;
				average_distance = total_distance / total_travelers;
				console.log( "AVERAGE STOPS: " + average_stops );
				console.log( "AVERAGE DISTANCE: " + average_distance );
				did_tally = true;
		}
    }

    function drawGame(){
		var canvas_element = document.getElementById( "game-canvas" );
		var context = canvas_element.getContext( "2d" );
		var place_canvas = document.getElementById( "place-canvas" );
		var traveler_canvas = document.getElementById( "traveler-canvas" );


		// Draw grid lines
		for ( column = 0; column < 11; ++column ){
			space = canvas.width / 10;
			context.beginPath();
			context.moveTo( column * space, 0 );
			context.lineTo( column * space, canvas.height );
			context.lineWidth = 1;
			context.strokeStyle = '#ccc';
			context.stroke();
		}
		for ( row = 0; row < 11; ++row ){
			space = canvas.height / 10;
			context.beginPath();
			context.moveTo( 0, row * space );
			context.lineTo( canvas.width, row * space );
			context.lineWidth = 1;
			context.strokeStyle = '#ccc';
			context.stroke();
		}

		if ( game.displays.places ) {
			for ( var count in places ){
				place = places[ count ];
				context.drawImage(place_canvas, place.x - game.sizes.place, place.y - game.sizes.place );
			}
		}


		if ( game.displays.potential_places ) {
			for ( var count in valid_places ){
				place = places[ valid_places[ count ] ];
				diameter = 10;
				context.beginPath();
				context.arc( place.x, place.y, diameter , 0, 2 * Math.PI );
				context.strokeStyle = '#006B54';
				context.stroke();
			}
		}



		// Draw History
		if ( game.displays.history ){
			for ( var pair_key in usage_history ){
				point_indexes = pair_key.split( '.' );
				start = places[ point_indexes[0] ];
				finish = places[ point_indexes[1] ];
				stroke_width = Math.round( usage_history[ pair_key ] );
				if(stroke_width > 10){
					stroke_width = 10;
				}

				context.beginPath();
				context.moveTo( start.x, start.y );
				context.lineTo( finish.x, finish.y );
				context.lineWidth = stroke_width;
				context.strokeStyle = '#000';
				context.stroke();
			}
		}
		for ( var count in travelers ){
			traveler = travelers[ count ];
			if ( game.displays.travelers ) {
				context.drawImage(traveler_canvas, traveler.x - game.sizes.traveler, traveler.y - game.sizes.traveler );
			}
			// Draw goal
			if ( game.displays.goals ) {
				context.beginPath();
				context.arc( places[ traveler.goal_place_index ].x, places[ traveler.goal_place_index ].y, 5 , 0, 2 * Math.PI );
				context.arc( places[ traveler.goal_place_index ].x, places[ traveler.goal_place_index ].y, 10 , 0, 2 * Math.PI );
				context.arc( places[ traveler.goal_place_index ].x, places[ traveler.goal_place_index ].y, 15 , 0, 2 * Math.PI );
				context.strokeStyle = '#006B54';
				context.stroke();
			}

			// Draw next chosen
			if ( game.displays.next_chosen && traveler.next_place != null ){
				context.beginPath();
				context.arc( places[ traveler.next_place ].x, places[ traveler.next_place ].y, 5 , 0, 2 * Math.PI );
				context.strokeStyle = '#CC3232';
				context.stroke();
			}

			context.strokeStyle = '#000';
		}

    }


    function init_travelers( number_of_travelers ){
    	single_goal = Math.floor( ( Math.random() * places.length - 1 ) + 1 );
	    for( count = 0; count < number_of_travelers; ++count ) {
		    traveler = {};
		    traveler.arrived = false;
		    traveler.start_place_index = Math.floor( ( Math.random() * places.length - 1 ) + 1 );
		    if ( game.single_goal ){
			    traveler.goal_place_index = single_goal;
		    } else {
			    while( traveler.goal_place_index == null || traveler.goal_place_index == traveler.start_place_index ){
				    traveler.goal_place_index  = Math.floor( ( Math.random() * places.length - 1 ) + 1 );
			    }
		    }
		    traveler.last_place = traveler.start_place_index;
		    traveler.next_place = null;
		    traveler.x          = places[ traveler.start_place_index ].x;
		    traveler.y          = places[ traveler.start_place_index ].y;
		    traveler.x_speed = 0;
		    traveler.y_speed = 0;
		    traveler.history = [];
		    traveler.distance_traveled = 0;
		    traveler.has_arrived = function( place_index ){
				if( Math.round( this.x ) == places[ place_index ].x &&
					Math.round( this.y ) == places[ place_index ].y
				){
					return true;
				}
				return false;
		    }



			traveler.choose_next_place = function(){
				valid_places = new Array;
				if ( this.next_place != null ){
					this.last_place = this.next_place;
				}
				this.x == places[ this.last_place ].x;
				this.y == places[ this.last_place ].y;

				this.history[ this.history.length ] = this.last_place;
				goal = places[ this.goal_place_index ];
				x_diff = this.x - goal.x;
				y_diff = this.y - goal.y;
				shortest_distance = null;
				for( var place_count in places ){
					valid = false;

					if ( place_count == this.last_place ){ continue; }
					if ( in_array( place_count, this.history ) ){ continue; }
					place = places[ place_count ];

					if ( goal.x <= Math.round( this.x ) ) {
						if ( place.x <= this.x ){
							valid = true;
						} else {
							valid = false;
							continue;
						}
					} else {
						if ( place.x >= Math.round( this.x ) ) {
							valid = true;
						} else {
							valid = false;
							continue;
						}
					}

					if ( goal.y <= Math.round( this.y ) ) {
						if ( place.y <= this.y ){
							valid = true;
						} else {
							valid = false;
							continue;
						}
					} else {
						if ( place.y >= Math.round( this.y ) ) {
							valid = true;
						} else {
							valid = false;
							continue;
						}
					}

					if ( valid ){
						valid_places[ valid_places.length ] = place_count;
						// this place is in the right direction.
						distance = get_distance( this, place );
						if ( distance < shortest_distance || shortest_distance === null ){
							shortest_distance = distance;
							this.next_place = place_count;
						}
					}
				}

				valid_places = [];

				current_grid_x = Math.floor( ( this.x / canvas.width ) * 10 );
				current_grid_y = Math.floor( ( this.y / canvas.height ) * 10 );

				for ( x_grid = current_grid_x - 1; x_grid <= current_grid_x + 1; ++x_grid ){
					if ( x_grid < 0 || x_grid > 10 ){
						continue;
					}
					for ( y_grid = current_grid_y - 1; y_grid <= current_grid_y + 1; ++y_grid ){
						if ( y_grid < 0 || y_grid > 10 ){
							continue;
						}
						for( var place_index in grid[ x_grid ][ y_grid ] ){
							valid_places[ valid_places.length ] = grid[ x_grid ][ y_grid ][ place_index ];
						}
					}
				}


			}
		    travelers[ count ] = traveler;
	    }
    }

	function init_places( number_of_places ){
		switch( game.options.layout ){
			case 'grid':
				count = 0;
				side_size = Math.floor( Math.sqrt( number_of_places ) );
				space = canvas.width / side_size;
				for ( column = 0; column < side_size; ++column ){
					for ( row = 0; row < side_size; ++row ){
						if ( count > number_of_places ){
							continue;
						}
						place = {};
						place.x = Math.floor( ( column * space ) + (space / 2 ) );
						place.y = Math.floor( ( row * space ) + ( space / 2 ) );
						places[ count ] = place;
						++count;
					}
				}
				break;
			case 'random':
			default:
			    for( count = 0; count < number_of_places; ++count ) {
					// Set up place positions
					place = {};
					place.x = Math.floor( ( Math.random() * canvas.width ) + 1 );
					place.y = Math.floor( ( Math.random() * canvas.height ) + 1 );

					places[ count ] = place;
			    }
				break;
		}

		for( column = 0; column < 11; ++column ){
			grid[ column ] = [];
			for( row = 0; row < 11;  ++row ){
				grid[ column ][ row ] = [];
			}
		}
		// Index places by position
		for( var place_count in places ){
			x_slot = Math.floor( ( places[ place_count ].x / canvas.width ) * 10 );
			y_slot = Math.floor( ( places[ place_count ].y / canvas.height ) * 10 );
			grid[ x_slot ][ y_slot ][ grid[ x_slot ][ y_slot ].length ] = place_count;
		}
	}
	function get_distance( first, second ){
		distance = Math.sqrt( Math.pow( ( first.x - second.x ), 2) + Math.pow( ( first.y - second.y ), 2) );
		return distance;
	}
		</script>
	</head>
	<body style="margin:0px">
		<div id="interface" style="position:absolute;background:#fff;opacity:.8;border:1px solid #ccc;">
			<div id="framerate">--</div>
			<div id="framerate-avg">--</div>
			<a href="#"id="reset">reset</a>
			<div id="displays">
				<ul>
				</ul>
			</div>

		</div>
		<canvas id="game-canvas"></canvas>
		<canvas id="place-canvas" width="12" height="12" style="display:none"></canvas>
		<canvas id="traveler-canvas" width="8" height="8" style="display:none"></canvas>
	</body>
</html>